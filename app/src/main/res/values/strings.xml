<resources>
    <string name="app_name">Pattern Guide</string>
    <string name="mainTitle">Design Patterns</string>
    <string name="appDescription">A short guide to Object-Oriented Design Patterns</string>
    <string name="patternDefiniton">In software engineering, a software design pattern is a general, reusable solution to a commonly occurring problem within a given context in software design. It is not a finished design that can be transformed directly into source or machine code. Rather, it is a description or template for how to solve a problem that can be used in many different situations. Design patterns are formalized best practices that the programmer can use to solve common problems when designing an application or system. (Wikipedia)</string>
    <string name="creationalPatternsLabel">Creational Patterns</string>
    <string name="structuralPatternsLabel">Structural Patterns</string>
    <string name="behavioralPatternsLabel">Behavioral Patterns</string>
    <string name="nextButtonText">Next</string>
    <string name="previousButtonText">Previous</string>
    <string name="patternSourceText">www.gofpatterns.com</string>
    <string-array name="creationalPatterns">
        <item>"Abstract Factory Pattern";"This pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes. Given a set of related abstract classes, the Abstract Factory pattern provides a way to create instances of those abstract classes from a matched set of concerte subclases. The "Abstract Factory" pattern provides an abstract class that determines the appropriate concrete class to instantiate to create a set of concrete products that implement a standard interface. The client interacts only with the product interfaces and the Abstract Factory class. The client never knows about the concrete construction classes provided by this pattern. The Abstract Factory pattern is similar to the Factory Method pattern, except it creates families of related objects."</item>
        <item>"Builder Pattern";"The Builder pattern separates the construction of a complex object from its representation so the same construction process can create different objects. The Builder pattern allows a client object to construct a complex object by specifying only its type and content. The client is shielded from the details of the object\'s construction. This simplifies the creation of complex objects by defining a class that builds instances of another class. The Builder pattern produces one main product and there might be more than one class in the product, but there is always one main class. When you use the Builder pattern, you create the complex objects one step at a time. Other patterns build the object in a single step."</item>
        <item>"Factory Method";"In a factory pattern, a concrete class with static methods is used to create instances of objects that implement an interface. The Factory Method pattern defines an interface for creating an object, but lets the subclasses decide which class to instantiate. The Factory method lets a class defer instantiation to subclasses, which is useful for constructing individual objects for a specific purpose without the requestor knowing the specific class being instantiated. This allows you to introduce new classes without modifying the code because the new class implements only the interface so it can be used by the client. You create a new factory class to create the new class and the factory class implements the factory interface."</item>
        <item>"Prototype Pattern";"The Prototype pattern allows an object to create customized objects without knowing their exact class or the details of how to create them.It specifies the kinds of objects to create using a prototypical instance, and creates new objects by copying this prototype. The Prototype pattern works by giving prototypical objects to an object and then initiates the creation of objects. The creation-initiating object then creates objects by asking the prototypical objects to make copies of themselves. The Prototype pattern makes creating objects dynamically easier by defining classes whose objects can duplicate themselves."</item>
        <item>"Singleton Pattern";"The Singleton pattern ensures that a class has only one instance, and provides a global point of access to that class. It ensures that all objects that use an instance of this class use the same instance."</item>
    </string-array>
    <string-array name="behavioralPatterns">
        <item>"Command Pattern";"The Command pattern encapsulates a request in an object, which enables you to store the command, pass the command to a method, and return the command like any other object."</item>
        <item>"Iterator Pattern";"The iterator pattern provides a consistent way to sequentially access items in a collection that is independent of and separate from the underlying collection."</item>
        <item>"Mediator Pattern";"The Mediator pattern simplifies communication among objects in a system by introducing a single object that manages message distribution among other objects. The Mediator pattern promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently."</item>
        <item>"Observer Pattern";"The Observer pattern provides a way for a component to flexibly broadcast messages to interested receivers. It defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically."</item>
        <item>"Strategy Pattern";"The intent of the Strategy Pattern is to define a family of algorithms, encapsulate each algorithm, and make them interchangeable. The Strategy Pattern lets the algorithm vary independently from clients that use it. In addition the pattern, defines a group of classes that represent a set of possible behaviors. These behaviors can then be used in an application to change its functionality."</item>
    </string-array>
    <string-array name="structuralPatterns">
        <item>"Adapter Pattern";"The Adapter pattern acts as an intermediary between two classes, converting the interface of one class so that it can be used with the other. This enables classes with incompatible interfaces to work together. The Adapter pattern implements an interface known to its clients and provides access to an instance of a class not known to its clients. An adapter object provides the functionality of an interface without having to know the class used to implement that interace."</item>
        <item>"Composite Pattern";"The Composite pattern enables you to create hierarchical tree structures of varying complexity, while allowing every element in the structure to operate with a uniform interface. The Composite pattern combines objects into tree structures to represent either the whole hierarchy or a part of the hierarchy. This means the Composite pattern allows clients to treat individual objects and compositions of objects uniformly."</item>
        <item>"Decorator Pattern";"The Decorator pattern enables you to add or remove object functionality without changing the external appearance or function of the object. It changes the functionality of an object in a way that is transparent to its clients by using an instance of a subclass of the original class that delegates operations to the original object. The Decorator pattern attaches additional responsibilities to an object dynamically to provide a flexible alternative to changing object functionality without using static inheritance."</item>
        <item>"Flyweight Pattern";"The Flyweight pattern reduces the number of low-level, detailed objects within a system by sharing objects. If instances of a class that contain the same information can be used interchangeably, the Flyweight pattern allows a program to avoid the expense of multiple instances that contain the same information by sharing one instance."</item>
        <item>"Flyweight Pattern";"The Flyweight pattern reduces the number of low-level, detailed objects within a system by sharing objects. If instances of a class that contain the same information can be used interchangeably, the Flyweight pattern allows a program to avoid the expense of multiple instances that contain the same information by sharing one instance."</item>
    </string-array>

</resources>